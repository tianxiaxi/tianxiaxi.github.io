[{"categories":null,"content":"关于 素问小站","date":"2023-04-05","objectID":"/about/","tags":null,"title":"关于素问小站","uri":"/about/"},{"categories":null,"content":"关于 一个一事无成却又兴趣广泛的码农。 ","date":"2023-04-05","objectID":"/about/:1:0","tags":null,"title":"关于素问小站","uri":"/about/"},{"categories":["github"],"content":"rax VS flutter VS taro VS Hippy VS chameleon 对比分析 本文档更新时间: 2023-03-19 对比项 rax flutter taro Hippy chameleon 仓库名称 rax flutter taro Hippy chameleon 是否公开 public public public public public 是否归档 未归档 未归档 未归档 未归档 未归档 创建时间 2016-10-14 07:53:50 2015-03-06 22:54:58 2018-04-08 09:32:26 2019-11-15 01:55:31 2019-01-18 14:41:35 创建时间(月) 截止目前共 78 个月 截止目前共 97 个月 截止目前共 60 个月 截止目前共 40 个月 截止目前共 50 个月 关注度 Watch: 204 Fork: 659 Starred: 7873 Opened Issues: 69 Watch: 3572 Fork: 24920 Starred: 151297 Opened Issues: 11519 Watch: 692 Fork: 4422 Starred: 32521 Opened Issues: 991 Watch: 210 Fork: 873 Starred: 7355 Opened Issues: 13 Watch: 239 Fork: 701 Starred: 8983 Opened Issues: 275 平均每月关注度 Watch: 2 Fork: 8 Starred: 100 Opened Issues: 0 Watch: 36 Fork: 256 Starred: 1559 Opened Issues: 118 Watch: 11 Fork: 73 Starred: 542 Opened Issues: 16 Watch: 5 Fork: 21 Starred: 183 Opened Issues: 0 Watch: 4 Fork: 14 Starred: 179 Opened Issues: 5 仓库描述 🐰 Rax is a progressive framework for building universal application. https://rax.js.org Flutter makes it easy and fast to build beautiful apps for mobile and beyond 开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发微信/京东/百度/支付宝/字节跳动/ QQ 小程序/H5/React Native 等应用。 https://taro.zone/ Hippy is designed to easily build cross-platform dynamic apps. 👏 🦎 一套代码运行多端，一端所见即多端所见 ","date":"2023-03-19","objectID":"/2023/03/github_repo_compare_rax_vsflutter_vstaro_vshippy_vschameleon/:1:0","tags":["github","rax","flutter","taro","Hippy","chameleon"],"title":"Github项目对比 - rax VS flutter VS taro VS Hippy VS chameleon","uri":"/2023/03/github_repo_compare_rax_vsflutter_vstaro_vshippy_vschameleon/"},{"categories":["github"],"content":"axum VS Rocket VS actix-web 对比分析 本文档更新时间: 2023-03-15 对比项 axum Rocket actix-web 仓库名称 axum Rocket actix-web 是否公开 public public public 是否归档 未归档 未归档 未归档 创建时间 2021-05-30 09:22:25 2016-03-18 02:50:18 2017-09-30 15:30:02 创建时间(月) 截止目前共 21 个月 截止目前共 85 个月 截止目前共 66 个月 关注度 Watch: 93 Fork: 638 Starred: 9082 Opened Issues: 26 Watch: 264 Fork: 1396 Starred: 20073 Opened Issues: 162 Watch: 224 Fork: 1478 Starred: 16898 Opened Issues: 147 平均每月关注度 Watch: 4 Fork: 30 Starred: 432 Opened Issues: 1 Watch: 3 Fork: 16 Starred: 236 Opened Issues: 1 Watch: 3 Fork: 22 Starred: 256 Opened Issues: 2 仓库描述 Ergonomic and modular web framework built with Tokio, Tower, and Hyper A web framework for Rust. Actix Web is a powerful, pragmatic, and extremely fast web framework for Rust. ","date":"2023-03-15","objectID":"/2023/03/github_repo_compare_axum_vsrocket_vsactix-web/:1:0","tags":["github","axum","Rocket","actix-web"],"title":"Github 开源项目对比分析 - axum VS Rocket VS actix-web","uri":"/2023/03/github_repo_compare_axum_vsrocket_vsactix-web/"},{"categories":["github"],"content":"AppFlowy VS AFFiNE VS logseq 对比分析 本文档更新时间: 2023-03-15 对比项 AppFlowy AFFiNE logseq 仓库名称 AppFlowy AFFiNE logseq 是否公开 public public public 是否归档 未归档 未归档 未归档 创建时间 2021-06-16 12:56:48 2022-07-31 18:45:21 2020-05-23 00:06:06 创建时间(月) 截止目前共 21 个月 截止目前共 7 个月 截止目前共 34 个月 关注度 Watch: 291 Fork: 1912 Starred: 32707 Opened Issues: 394 Watch: 122 Fork: 648 Starred: 13635 Opened Issues: 153 Watch: 177 Fork: 1262 Starred: 21028 Opened Issues: 1408 平均每月关注度 Watch: 13 Fork: 91 Starred: 1557 Opened Issues: 18 Watch: 17 Fork: 92 Starred: 1947 Opened Issues: 21 Watch: 5 Fork: 37 Starred: 618 Opened Issues: 41 仓库描述 AppFlowy is an open-source alternative to Notion. You are in charge of your data and customizations. Built with Flutter and Rust. There can be more than Notion and Miro. AFFiNE is a next-gen knowledge base that brings planning, sorting and creating all together. Privacy first, open-source, customizable and ready to use. A privacy-first, open-source platform for knowledge management and collaboration. Download link: http://github.com/logseq/logseq/releases. roadmap: http://trello.com/b/8txSM12G/roadmap ","date":"2023-03-15","objectID":"/2023/03/github_repo_compare_appflowy_vsaffine_vslogseq/:1:0","tags":["github","AppFlowy","AFFiNE","logseq"],"title":"Github 开源项目对比分析 - AppFlowy VS AFFiNE VS logseq","uri":"/2023/03/github_repo_compare_appflowy_vsaffine_vslogseq/"},{"categories":null,"content":"mongoose介绍 mongoose 是一个标准的 C 语言网络通信模块，是嵌入式网络编程的瑞士军刀。mongoose 提供非阻塞的事件驱动的 TCP, UDP, HTTP, WebSocket, CoAP, MQTT 的服务端与客户端模式的APIs。 mongoose 主要包含如下功能： Cross-platform: works on Linux/UNIX, MacOS, QNX, eCos, Windows, Android, iPhone, FreeRTOS (TI CC3200, ESP8266), etc Supported hardware platforms: TI CC3200, TI MSP432, NRF52, STM32, PIC32, ESP8266, ESP32 and more Builtin protocols: plain TCP, plain UDP, SSL/TLS (over TCP, one-way or two-way) HTTP client, HTTP server WebSocket client, WebSocket server MQTT client, MQTT broker CoAP client, CoAP server DNS client, DNS server, async DNS resolver Single-threaded, asynchronous, non-blocking core with simple event-based API Native support for PicoTCP embedded TCP/IP stack, LWIP embedded TCP/IP stack Tiny static and run-time footprint Source code is both ISO C and ISO C++ compliant Very easy to integrate: just copy mongoose.c and mongoose.h files to your build tree ","date":"2023-03-09","objectID":"/2023/03/mongoose/:1:0","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"mongoose使用 mongoose 基本数据结构 struct mg_mgr 管理所有活动的连接 struct mg_connection 用于描述和维护一个connection连接 struct mbuf 管理和维护发送/接收的数据缓冲区 mongoose 使用示例 // declare and initialise event manager struct mg_mgr mgr; mg_mgr_init(\u0026mgr, NULL); // Create connections // For example, a server application should create listening connections struct mg_connection *c = mg_bind(\u0026mgr, \"80\", ev_handler_function); mg_set_protocol_http_websocket(c); // create an event loop by calling mg_mgr_poll() in a loop for (;;) { mg_mgr_poll(\u0026mgr, 1000); } ","date":"2023-03-09","objectID":"/2023/03/mongoose/:2:0","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"Memory buffers 每个connection连接都有一个数据发送缓冲区（struct mg_connection::send_mbuf）与数据接收缓冲区（struct mg_connection::recv_mbuf）。当接收到数据时，mongoose将数据添加到recv_mbuf，并触发recv_mbuf 事件消息；当mongoose发送数据后，将已发送的数据从struct mg_connection::send_mbuf 中抛弃，并触发MG_EV_SEND 事件消息；当connection连接关闭时，将发送MG_EV_CLOSE 事件消息。 ","date":"2023-03-09","objectID":"/2023/03/mongoose/:2:1","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"Event handler Event handler function的处理示例如下： static void ev_handler(struct ns_connection *nc, int ev, void *p) { switch (ev) { case NS_ACCEPT: case NS_CONNECT: // Do something break; case NS_CLOSE: // close event break; case NS_RECV: // data received break; default: break; } } 主要参数说明如下： struct mg_connection *nc 收到数据对应的connection int ev Event number，请参考《mongoose支持的Event列表》 void *p 接收到的数据的指针，不同消息该参数有不同的含义 mongoose支持的Event列表： MG_EV_ACCEPT: sent when a new server connection is accepted by a listening connection. void *ev_data is union socket_address of the remote peer. MG_EV_CONNECT: sent when a new outbound connection created by mg_connect() either failed or succeeded. void *ev_data is int *success. If success is 0, then the connection has been established, otherwise it contains an error code. See mg_connect_opt() function for code example. MG_EV_RECV: New data is received and appended to the end of recv_mbuf. void *ev_data is int *num_received_bytes. Typically, event handler should check received data in nc-\u003erecv_mbuf, discard processed data by calling mbuf_remove(), set connection flags nc-\u003eflags if necessary (see structmg_connection) and write data the remote peer by output functions like mg_send(). WARNING: Mongoose uses realloc() to expand the receive buffer. It is the user’s responsibility to discard processed data from the beginning of the receive buffer, note the mbuf_remove() call in the example above. MG_EV_SEND: Mongoose has written data to the remote peer and discarded written data from the mg_connection::send_mbuf. void *ev_data is int*num_sent_bytes. NOTE: Mongoose output functions only append data to the mg_connection::send_mbuf. They do not do any socket writes. An actual IO is done by mg_mgr_poll(). An MG_EV_SEND event is just a notification about an IO has been done. MG_EV_POLL: Sent to all connections on each invocation of mg_mgr_poll(). This event could be used to do any housekeeping, for example check whether a certain timeout has expired and closes the connection or send heartbeat message, etc. MG_EV_TIMER: Sent to the connection if mg_set_timer() was called. ","date":"2023-03-09","objectID":"/2023/03/mongoose/:2:2","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"Connection address format mongoose 创建conecction连接地址格式如下： [PROTO://][HOST:]PORT PROTO 协议名称，如 TCP 、 UDP 等，默认是 TCP HOST 连接的IPv4/IPv6地址名HOST名称 PORT 连接的端口号 connection连接地址格式示例： udp://8080 tcp://127.0.0.1:8080 ","date":"2023-03-09","objectID":"/2023/03/mongoose/:2:3","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"Using SSL on TCP SSL_CERT PEM format certificate. For listening connections, certificate file must contain private key and server certificate concatenated together; For client connections, it should be a client certificate file. CA_CERT PEM format certificate. A certificate authority (CA) PEM file, and it is optional (can be set to NULL). If ca_cert is non-NULL, then the connection is so-called two-way-SSL: other peer’s certificate is checked against the ca_cert. int main(void) { struct mg_mgr mgr; struct mg_connection *c; struct mg_bind_opts bind_opts; mg_mgr_init(\u0026mgr, NULL); memset(\u0026bind_opts, 0, sizeof(bind_opts)); bind_opts.ssl_cert = \"cert.pem\"; bind_opts.ssl_key = \"key.pem\"; // Use bind_opts to specify SSL certificate \u0026 key file c = mg_bind_opt(\u0026mgr, \"443\", ev_handler, bind_opts); mg_set_protocol_http_websocket(c); ... } SSL证书生成方式： # @see: https://www.openssl.org/docs/manmaster/man1/openssl-req.html openssl req -nodes -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 9999 ","date":"2023-03-09","objectID":"/2023/03/mongoose/:2:4","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"参考引用 https://github.com/cesanta/mongoose https://cesanta.com/docs/overview/intro.html https://www.openssl.org/docs/manmaster/man1/openssl-req.html ","date":"2023-03-09","objectID":"/2023/03/mongoose/:3:0","tags":["mongoose","网络通信"],"title":"mongoose介绍","uri":"/2023/03/mongoose/"},{"categories":null,"content":"cookie/session ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:1:0","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"cookie cookie是一种客户端会话跟踪技术，用于将网页的数据存储到浏览器中。当关闭浏览器或到过期时间时，cookie将失效。 cookie存在大小限制，一般个数限制为20~50，大小限制在4KB左右。 cookie在每次请求时将携带在HTTP头中，如果cookie保存过多数据可能存在性能问题。 Caution: 浏览器可能禁用cookie 不要利用cookie保存隐私数据 设置HttpOnly属性可避免XSS攻击 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:1:1","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"session session为会话数据，保存在Web服务器上，主要负责访问者与网站之间的交互。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:1:2","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"HTML5新增存储方案 HTML5中新增存储方案，包括sessionStorage、localStorage、WebSQL、IndexedDB。下列所有存储方案均遵循同源策略限制。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:2:0","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"localStorage localStorage生命周期是永久，可实现数据持久化存储。除非用户手动清除，否则localStorage存储的数据一直保存在浏览器中。 localStorage的大小一般为5MB，不参与与服务端的通信。 Caution: localStorage在浏览器隐私模式下不可读取；存储内容多会消耗内存空间，导致页面卡顿。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:2:1","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"sessionStorage sessionStorage仅在当前会话下有效，关闭页面或者浏览器后被清理并失效。 sessionStorage的大小一般为5MB。 Caution: sessionStorage无法跨Tab共享： 打开新页面时，将导致session失效；通过Duplicate 复制Tab时，sessionStorage失效。故在持久化存储时，优先考虑localStorage。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:2:2","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"WebSQL WebSQL数据库API不是HTML5规范的一部分，但它是一个独立的规范，引入一组使用SQL操作客户端数据库的API。 WebSQL与关系数据库的概念相似，支持openDatabase/transaction/executeSQL 等操作，在Chrome浏览器中支持，一般情况下较少使用，作为临时存储或缓存使用。 Caution: 仅Chrome、Safari、Opera支持，IE、Firefox等浏览器不支持。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:2:3","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"IndexedDB IndexedDB是浏览器提供的本地数据库存储，允许存储大容量数据，提供查找接口、建立索引等功能；但IndexedDB不支持SQL，接近NoSQL数据库。 IndexedDB具有键值存储、异步、支持事务、同源限制（不支持跨域访问）、大容量（\u003e=250MB）、支持二进制等特性。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:2:4","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"前端框架存储方案介绍 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:3:0","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"React Redux-persist Redux-persist 通过将redux存储的数据缓存到localStorage中实现数据持久化存储。 react-redux React-redux将数据存储在内存中，当页面刷新时，存储的数据将被重置。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:3:1","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"其它存储方案 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:4:0","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"Cache Storage Cache Storage存储Response对象，即存储HTTP响应。Cache Storage是多个Cache的集合，每个Cache可以存储多个Response对象。 Cache Storage在浏览器上的引用名是caches而不是驼峰写法的cacheStorage ，它定义在ServiceWorker规范中。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:4:1","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"Application Cache HTML5引入了应用程序缓存技术，意味着web应用可以进行缓存。在没有网络的情况下，通过创建cache manifest文件，可以轻松创建离线应用。目前主流浏览器均支持Application cache。 Application cache有三个优势：离线浏览、提升页面的载入速度、降低服务器压力。 Application cache主要存储静态资源。使用时服务端需要维护一个manifest清单，浏览器需要进行简单设置。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:4:2","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"应用场景分析 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:5:0","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":null,"content":"存储用户登陆状态 在大多数Web应用中，当用户登陆后，后端生成无意义的字符串token ，同时将token返回给前端。前端在后续所有请求中，将token附加到Header中传输到后端，后端进行token校验。前端在存储Token时，主流的如下几种方案： sessionStorage: 会话期间内存储，但无法跨浏览器Tab共享数据。 localStrogage: 永久存储。当token过期时，需要重新设置，涉及同步处理；当网站被XSS注入攻击后，对方可能截取localStorage中的数据；localStorage是同步操作，频繁读取可能存在性能问题。 cookie: 使用cookie存储用户登陆状态是目前Web开发主流中的主流。 ","date":"2023-03-09","objectID":"/2023/03/frontend_storage/:5:1","tags":["存储","前端"],"title":"前端存储方案","uri":"/2023/03/frontend_storage/"},{"categories":["读书笔记"],"content":"《读书与做人》简介 一代学术宗师季羡林先生，道德高尚，学问渊深，文章亦足以动人。 季老谈读书，深入浅出，举重若轻，以大学者而写作小文章，从中可见出一代学问家对学术的真诚与崇敬，读者亦可从中体悟到文史学科的一般入门途径。 季老论人生，信笔拈来，娓娓道出，以近于期颐之历练与心态，平和面对人世间的种种苦难，深于情，而不矫揉造作；明于理，而以平实朴素笔调发之，可给人以启迪与心灵的抚慰。 ","date":"2023-03-09","objectID":"/2023/03/jixianlin_dushu_yu_zuoren/:1:0","tags":["读书笔记"],"title":"读书笔记 - [季羡林]读书与做人","uri":"/2023/03/jixianlin_dushu_yu_zuoren/"},{"categories":["读书笔记"],"content":"读书笔记 上个月初购买kindle之后，一段时间内致力于kindle电子书的收集，《读书与做人》是第一本找到的令人满意的电子书。在新阅读设备及新书的双重愉悦下，利用一个星期的业余时间阅读完该书，颇有收获，闲暇时记录下来以备将来复习。 从书名来看，包括读书与做人两部分，但从内容角度，可以分为自传、序集、做人三部分。 第一部分自传，从出生、小学、中学、大学、德国留学、归国后北大任教、翻译及文学推广，简短的文字描述了季老平淡、充实、传奇的一生。通过作者的自述，发现大部份熟知的成功人士所具备的经历在季老身上都完美呈现。在小时候不仅有极高的语言天赋，还博学多识，有读无类，不管英语或国学，都为接下来的发展打下坚实的基础。人并非生而知之，一个人的成功，离不开外缘与内因，在清华读书期间，跟随陈寅恪、朱光潜两位国学大师学习，潜移默化中影响深远，终身在这条道路上奋斗，是为外缘；德国哥廷根留学期间，潜心研学佛教史及梵文、巴利文、俄文、火星罗文等多门语言，正所谓十年寒窗无人知，一朝成名天下知，十年闭关研学是为内因，积淀与升华，成为一代国学大师与学界泰斗。这让我想到了另一位国学大师南怀谨，也有类似的经历，早年游学，涉猎多方，峨眉山三年关闭，为后续人生道路奠下基础。 第二部分序集，是季老为其它出版作品写书的序言集合。生平很少写序言，写必有因，写必无假话，其书都可以作为我们的补充阅读。 第三部分做人，流露出对青年一代做事做人的殷切关怀，以小见大，讨论人与自然、人与自身、人与社会的相处之道，也是对其自身的总结与自述。 经过这本书，认识到季老是如此一个可爱的人，有风趣、有风骨、有脾气，恰是一个身边人，恰是我们的一个外缘。 ","date":"2023-03-09","objectID":"/2023/03/jixianlin_dushu_yu_zuoren/:2:0","tags":["读书笔记"],"title":"读书笔记 - [季羡林]读书与做人","uri":"/2023/03/jixianlin_dushu_yu_zuoren/"},{"categories":null,"content":" Clang-format简介 clang-format是一个代码格式化的工具，支持C/C++/Java/JavaScript/Objective-C/Protobuf等多种语言，并提供LLVM、Google、Visual Studio（仅VSCode支持）、Chromium、Mozilla、WebKit等多种默认代码规范支持。 ","date":"2023-03-09","objectID":"/2023/03/clang_format/:0:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"Usage $ clang-format -help OVERVIEW: A tool to format C/C++/Java/JavaScript/Objective-C/Protobuf code. If no arguments are specified, it formats the code from standard input and writes the result to the standard output. If \u003cfile\u003es are given, it reformats the files. If -i is specified together with \u003cfile\u003es, the files are edited in-place. Otherwise, the result is written to the standard output. USAGE: clang-format [options] [\u003cfile\u003e ...] OPTIONS: Clang-format options: -assume-filename=\u003cstring\u003e - When reading from stdin, clang-format assumes this filename to look for a style config file (with -style=file) and to determine the language. -cursor=\u003cuint\u003e - The position of the cursor when invoking clang-format from an editor integration -dump-config - Dump configuration options to stdout and exit. Can be used with -style option. -fallback-style=\u003cstring\u003e - The name of the predefined style used as a fallback in case clang-format is invoked with -style=file, but can not find the .clang-format file to use. Use -fallback-style=none to skip formatting. -i - Inplace edit \u003cfile\u003es, if specified. -length=\u003cuint\u003e - Format a range of this length (in bytes). Multiple ranges can be formatted by specifying several -offset and -length pairs. When only a single -offset is specified without -length, clang-format will format up to the end of the file. Can only be used with one input file. -lines=\u003cstring\u003e - \u003cstart line\u003e:\u003cend line\u003e - format a range of lines (both 1-based). Multiple ranges can be formatted by specifying several -lines arguments. Can't be used with -offset and -length. Can only be used with one input file. -offset=\u003cuint\u003e - Format a range starting at this byte offset. Multiple ranges can be formatted by specifying several -offset and -length pairs. Can only be used with one input file. -output-replacements-xml - Output replacements as XML. -sort-includes - Sort touched include lines -style=\u003cstring\u003e - Coding style, currently supports: LLVM, Google, Chromium, Mozilla, WebKit. Use -style=file to load style configuration from .clang-format file located in one of the parent directories of the source file (or current directory for stdin). Use -style=\"{key: value, ...}\" to set specific parameters, e.g.: -style=\"{BasedOnStyle: llvm, IndentWidth: 8}\" -verbose - If set, shows the list of processed files Generic Options: -help - Display available options (-help-hidden for more) -help-list - Display list of available options (-help-list-hidden for more) -version - Display the version of this program 创建.clang-format文件 clang-format -style=google -dump-config \u003e .clang-format ","date":"2023-03-09","objectID":"/2023/03/clang_format/:1:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"Clang-Format配置介绍 Clang-Format 可以通过 -style=\"{key: value, …}\" 直接指定命令行参数的配置，也可以通过 -style=file 指定代码格式化配置文件；也可以从工作目录中读取.clang-format 或 _clang-format代码格式化配置文件。 .clang-format是一个YAML格式的配置文件： key1: value1 key2: value2 # A comment. ... .clang-format文件可以同时配置多种语言的格式化配置参数，文件前面未指定的配置项为默认配置项，对所有语言都有效，但指定语言下相同的配置项将覆盖默认的配置项。clang-format工具可以自动识别代码文件的语言类型，也可以通过-assume-filename=指定语言。多语言的配置文件示例如下： --- # We'll use defaults from the LLVM style, but with 4 columns indentation. BasedOnStyle: LLVM IndentWidth: 4 --- Language: Cpp # Force pointers to the type for C++. DerivePointerAlignment: false PointerAlignment: Left --- Language: JavaScript # Use 100 columns for JS. ColumnLimit: 100 --- Language: Proto # Don't format .proto files. DisableFormat: true ... 当不期望clang-format格式化某一段代码时，可以采用下面的注释： int formatted_code; // clang-format off void unformatted_code ; // clang-format on void formatted_code_again; 注： // clang-format on or /* clang-format on */等效 // clang-format off or /* clang-format off */等效 ","date":"2023-03-09","objectID":"/2023/03/clang_format/:2:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"Clang-Format 可选配置列表 (常用) BasedOnStyle_ (string）_ 指定标准的基础代码规范式样，取值包括 LLVM、Google、Chromium、Mozilla、WebKit等 AccessModifierOffset_ (int)_ 访问权限关键字的缩进，如public AlignAfterOpenBracket 括号中的参数是否需要对齐 **AlignConsecutiveAssignments **(bool) 赋值操作时是否需要对齐，如当设置为true时， int aaaa = 12; int b = 23; int ccc = 23; - **AlignConsecutiveDeclarations **_(bool)_ \u003e 变量声明时是否需要对齐，如当设置为true时 \u003e ```cpp int aaaa = 12; float b = 23; std::string ccc = 23; AlignEscapedNewlines 使用backslashes()换行时()的设置方式，包括不对齐、左对齐、右对齐 **AlignOperands **(bool) 表达式或者语句拆分为多行时的是否需要对齐 int aaa = bbbbbbbbbbbbbbb + ccccccccccccccc; - **AlignTrailingComments **_(bool)_ \u003e 注释是否需要对齐 - **AllowAllParametersOfDeclarationOnNextLine **_(bool)_ \u003e 如何函数声明时包含多行，每个参数是否需要单独列一行 - **AllowShortBlocksOnASingleLine **_(bool)_ \u003e 简单语句是否需要写在一行。 E.g., this allows `if (a) { return; }` to be put on a single line. - **AllowShortCaseLabelsOnASingleLine **_(bool)_ \u003e case标签是否需要保持在一行 ```cpp // true: // false: switch (a) { vs. switch (a) { case 1: x = 1; break; case 1: case 2: return; x = 1; } break; case 2: return; } AllowShortFunctionsOnASingleLine 短函数是否可以保持在一行 **AllowShortIfStatementsOnASingleLine **(bool) 简单 if 语句是否可以保持在一行 **AllowShortLoopsOnASingleLine **(bool) 简单循环语句是否可以保持在一行 AlwaysBreakAfterReturnType 数据返回值的可选格式 AlwaysBreakTemplateDeclarations 模板声明时的换行式样 **BinPackArguments **(bool) 函数调用时参数放在一行还是每个参数一行 **BinPackParameters **(bool) 函数声明或定义时参数放在一行还是每个参数一行 BraceWrapping / BreakBeforeBraces 大括号的使用方式 **BreakBeforeTernaryOperators **(bool) 三元操作符时是否需要换行 true: veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ? firstValue : SecondValueVeryVeryVeryVeryLong; false: veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ? firstValue : SecondValueVeryVeryVeryVeryLong; BreakConstructorInitializers 构造函数成员初始化列表的的式样配置 BreakInheritanceList 类多重继承时父类的式样配置 **BreakStringLiterals **(bool) 是否允许对字符串进行格式化 **ColumnLimit **(unsigned) The column limit. A column limit of 0 means that there is no column limit. In this case, clang-format will respect the input’s line breaking decisions within statements unless they contradict other rules. **CompactNamespaces **(bool) 是否允许namespace打包到一行，或者每个namespace分行 true: namespace Foo { namespace Bar { }} false: namespace Foo { namespace Bar { } } ConstructorInitializerAllOnOneLineOrOnePerLine If the constructor initializers don’t fit on a line, put each initializer on its own line. ConstructorInitializerIndentWidth (unsigned) 构造函数成员初始化列表的缩进数量 ContinuationIndentWidth (unsigned) 行缩进数量 Cpp11BracedListStyle (bool) If true, format braced lists as best suited for C++11 braced lists. true: false: vector\u003cint\u003e x{1, 2, 3, 4}; vs. vector\u003cint\u003e x{ 1, 2, 3, 4 }; vector\u003cT\u003e x{{}, {}, {}, {}}; vector\u003cT\u003e x{ {}, {}, {}, {} }; f(MyMap[{composite, key}]); f(MyMap[{ composite, key }]); new int[3]{1, 2, 3}; new int[3]{ 1, 2, 3 }; DerivePointerAlignment (bool) \u0026 and *的对齐方式 DisableFormat (bool) 是否禁止代码格式化 FixNamespaceComments (bool) 是否自动添加namespace的结束注释 true: false: namespace a { vs. namespace a { foo(); foo(); } // namespace a; } IncludeBlocks (IncludeBlocksStyle) Dependent on the value, multiple #include blocks can be sorted as one and divided based on category. IndentCaseLabels (bool) case 语句是否需要缩进 false: true: switch (fool) { vs. switch (fool) { case 1: case 1: bar(); bar(); break; break; default: default: plop(); plop(); } } IndentPPDirectives (PPDirectiveIndentStyle) 预处理指令或宏的缩进方式 IndentWidth (unsigned) 行缩进的字符数量 KeepEmptyLinesAtTheStartOfBlocks (bool) 是否需要在代码段前保持空行 true: false: if (foo) { vs. if (foo) { bar(); bar(); } } Language (LanguageKind) 指定语言类型 LK_None (in configuration: None) Do not use. LK_Cpp (in configuration: Cpp) Should be used for C, C++. LK_Java (in configuration: Java) Should be used for Java. LK_JavaScript (in configuration: JavaScript) Should be used for JavaScript. LK_ObjC (in configuration: ObjC) Should be used for Objective-C, Objective-C++. LK_Proto (in configuration: Proto) Should be used for Protocol Buffers (https://developers.google.com/protocol-buffers/). LK_TableGen (in configuration: Tabl","date":"2023-03-09","objectID":"/2023/03/clang_format/:2:1","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":".clang-format 配置文件示例 # Style options please see https://clang.llvm.org/docs/ClangFormatStyleOptions.html # The number of columns to use for indentation IndentWidth: 4 --- Language: Cpp BasedOnStyle: Google # The extra indent or outdent of access modifiers, e.g. public AccessModifierOffset: -1 # 括号中的参数是否需要对齐 AlignAfterOpenBracket: Align # 连续的赋值语句是否需要在'='处对齐 AlignConsecutiveAssignments: true # 连续声明的变更是否需要对齐 AlignConsecutiveDeclarations: false # Options for aligning backslashes in escaped newlines AlignEscapedNewlines: Left # 操作数及三元操作符对齐 AlignOperands: true # 注释对齐 AlignTrailingComments: true # 函数声明过长时是否每个参数作为一行处理 AllowAllParametersOfDeclarationOnNextLine: false # Allows contracting simple braced statements to a single line AllowShortBlocksOnASingleLine: false # case关键字是否与语句放在一行 AllowShortCaseLabelsOnASingleLine: false # 单语句或短函数是否可以放在一行 AllowShortFunctionsOnASingleLine: Inline # IF 单语句代码是否可以放在一行 AllowShortIfStatementsOnASingleLine: true # 单语句循环体是否可以与循环放在一行 AllowShortLoopsOnASingleLine: true # AlwaysBreakAfterDefinitionReturnType 选项将被弃用 AlwaysBreakAfterDefinitionReturnType: None # The function declaration return type breaking style to use AlwaysBreakAfterReturnType: None # 多行字符串是否需要另起一行 AlwaysBreakBeforeMultilineStrings: true # 模板声明时是否需要另起一行 AlwaysBreakTemplateDeclarations: Yes # 函数调用时参数打包对齐 BinPackArguments: true # 函数声明或定义时是否需要参数打包对齐 BinPackParameters: false # 大括号的处理行为 BraceWrapping: AfterClass: false AfterControlStatement: false AfterEnum: false AfterFunction: false AfterNamespace: false AfterObjCDeclaration: false AfterStruct: false AfterUnion: false AfterExternBlock: false BeforeCatch: false BeforeElse: false IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: true # The way to wrap binary operators BreakBeforeBinaryOperators: None # The brace breaking style to use BreakBeforeBraces: Attach BreakBeforeInheritanceComma: false # The inheritance list style to use BreakInheritanceList: AfterColon # 三元操作号对齐 BreakBeforeTernaryOperators: true BreakConstructorInitializersBeforeComma: false BreakConstructorInitializers: BeforeColon BreakAfterJavaFieldAnnotations: false # Allow breaking string literals when formatting BreakStringLiterals: true # 允许每行字符最大长度 ColumnLimit: 120 CommentPragmas: '^ IWYU pragma:' # 是否允许多个namespace声明在同一行 CompactNamespaces: false # If the constructor initializers don’t fit on a line, put each initializer on its own line ConstructorInitializerAllOnOneLineOrOnePerLine: true # The number of characters to use for indentation of constructor initializer lists as well as inheritance lists ConstructorInitializerIndentWidth: 4 # Indent width for line continuations ContinuationIndentWidth: 4 Cpp11BracedListStyle: true DerivePointerAlignment: true # 禁止代码格式化 DisableFormat: false ExperimentalAutoDetectBinPacking: false # 是否自动添加namespace结束的注释 FixNamespaceComments: true ForEachMacros: - foreach - Q_FOREACH - BOOST_FOREACH # Dependent on the value, multiple #include blocks can be sorted as one and divided based on category IncludeBlocks: Preserve # Regular expressions denoting the different #include categories used for ordering #includes IncludeCategories: - Regex: '^\u003cext/.*\\.h\u003e' Priority: 2 - Regex: '^\u003c.*\\.h\u003e' Priority: 1 - Regex: '^\u003c.*' Priority: 2 - Regex: '.*' Priority: 3 IncludeIsMainRegex: '([-_](test|unittest))?$' # case关键字是否需要缩进 IndentCaseLabels: true # 预处理指定或宏是否需要缩进 IndentPPDirectives: None # 当函数声明的返回值与函数名不在一行时，函数名是否需要缩进 IndentWrappedFunctionNames: false JavaScriptQuotes: Leave JavaScriptWrapImports: true # 是否在代码段前添加空格 KeepEmptyLinesAtTheStartOfBlocks: false MacroBlockBegin: '' MacroBlockEnd: '' # 允许最大的空行数量 MaxEmptyLinesToKeep: 1 # namespace中的子namespace与代码是否需要缩进 NamespaceIndentation: None ObjCBinPackProtocolList: Never ObjCBlockIndentWidth: 2 ObjCSpaceAfterProperty: false ObjCSpaceBeforeProtocolList: true PenaltyBreakAssignment: 2 PenaltyBreakBeforeFirstCallParameter: 1 PenaltyBreakComment: 300 PenaltyBreakFirstLessLess: 120 PenaltyBreakString: 1000 PenaltyBreakTemplateDeclaration: 10","date":"2023-03-09","objectID":"/2023/03/clang_format/:3:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"VSCode Coding Formating插件 VSCode的C/C++插件使用Clang-Format支持源代码格式化。 ","date":"2023-03-09","objectID":"/2023/03/clang_format/:4:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"编辑器设置 editor.formatOnSave - 保存文档时自动对代码格式化 editor.formatOnType - 当用户输入分号（;）时对代码进行格式化 注： 当对代码进行格式化时，VSCode优先检查当前工作空间是否存在.clang-format文件，如果存在则采用此文件进行格式化，否则采用默认的C_Cpp.clang_format_fallbackStyle进行格式化。同时可以通过C_Cpp.clang_format_path指定本机指定版本的clang-format工具代码默认的版本。 ","date":"2023-03-09","objectID":"/2023/03/clang_format/:4:1","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"VIM集成 请参考 https://clang.llvm.org/docs/ClangFormat.html#vim-integration ","date":"2023-03-09","objectID":"/2023/03/clang_format/:5:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":null,"content":"Emacs集成 请参考 https://clang.llvm.org/docs/ClangFormat.html#emacs-integration 扩展阅读 VSCode Code formatting介绍 Clang-Format 使用说明 Clang-Format Style Options ","date":"2023-03-09","objectID":"/2023/03/clang_format/:6:0","tags":["代码格式化","clang-format"],"title":"Clang format for C/C++/Java/JavaScript/Object-C","uri":"/2023/03/clang_format/"},{"categories":["software"],"content":"开发必备工具 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:1:0","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"VSCode Website: https://code.visualstudio.com/ 简介：This is the only editor which I used for my develop career since vscode released. Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages and runtimes (such as C++, C#, Java, Python, PHP, Go, .NET). ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:1:1","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"Warp Website: https://www.warp.dev/ 简介: The terminal for the 21st century. Modern features for modern development. Warp is a blazingly fast, Rust-based terminal that makes you and your team more productive at running, debugging, and deploying code. ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:1:2","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"终端与命令行 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:0","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"ripgrep ( rg ) Website: https://github.com/BurntSushi/ripgrep 简介： ripgrep is a line-oriented search tool that recursively searches the current directory for a regex pattern. ripgrep is a line-oriented search tool that recursively searches the current directory for a regex pattern. By default, ripgrep will respect gitignore rules and automatically skip hidden files/directories and binary files. (To disable all automatic filtering by default, use rg -uuu.) ripgrep has first class support on Windows, macOS and Linux, with binary downloads available for every release. ripgrep is similar to other popular search tools like The Silver Searcher, ack and grep. ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:1","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"fx Website: https://github.com/antonmedv/fx 简介: 一款格式化JSON的命令行工具，支持多颜色主题。 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:2","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"json_pp 简介: 一款格式化JSON的命令行工具。 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:3","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"hexyl Website: [https://github.com/sharkdp/hexy](https://github.com/sharkdp/hexyl) l 简介: A command-line hex viewer。 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:4","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"fx Website: https://github.com/axiros/terminal_markdown_viewer 简介: Styled Terminal Markdown Viewer。 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:2:5","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"少数派 ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:3:0","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"},{"categories":["software"],"content":"Snipaste Website: https://www.snipaste.com/ 简介: Snipaste is a simple but powerful snipping tool, and also allows you to pin the screenshot back onto the screen. You can also convert text or color info in the clipboard into a floating image window. Such windows can be zoomed, rotated, flipped, made translucent, and even made click-through! If you are a programmer, a designer or whoever works much time before the computer, you will be surprised how it can help you get your work done more efficiently! ","date":"2023-03-07","objectID":"/2023/03/personal-recommend-utils/:3:1","tags":["software","utils"],"title":"个人常用工具集","uri":"/2023/03/personal-recommend-utils/"}]