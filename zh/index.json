[{"content":"","permalink":"https://blog.yygz.org/zh/about/","summary":"","title":"About"},{"content":"\nmongoose介绍 mongoose 是一个标准的 C 语言网络通信模块，是嵌入式网络编程的瑞士军刀。mongoose 提供非阻塞的事件驱动的 TCP, UDP, HTTP, WebSocket, CoAP, MQTT 的服务端与客户端模式的APIs。\nmongoose 主要包含如下功能：\nCross-platform: works on Linux/UNIX, MacOS, QNX, eCos, Windows, Android, iPhone, FreeRTOS (TI CC3200, ESP8266), etc\nSupported hardware platforms: TI CC3200, TI MSP432, NRF52, STM32, PIC32, ESP8266, ESP32 and more\nBuiltin protocols:\nplain TCP, plain UDP, SSL/TLS (over TCP, one-way or two-way)\nHTTP client, HTTP server\nWebSocket client, WebSocket server\nMQTT client, MQTT broker\nCoAP client, CoAP server\nDNS client, DNS server, async DNS resolver\nSingle-threaded, asynchronous, non-blocking core with simple event-based API\nNative support for PicoTCP embedded TCP/IP stack, LWIP embedded TCP/IP stack\nTiny static and run-time footprint\nSource code is both ISO C and ISO C++ compliant\nVery easy to integrate: just copy mongoose.c and mongoose.h files to your build tree\nmongoose使用 mongoose 基本数据结构\nstruct mg_mgr 管理所有活动的连接\nstruct mg_connection 用于描述和维护一个connection连接\nstruct mbuf 管理和维护发送/接收的数据缓冲区\nmongoose 使用示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 // declare and initialise event manager struct mg_mgr mgr; mg_mgr_init(\u0026amp;mgr, NULL); // Create connections // For example, a server application should create listening connections struct mg_connection *c = mg_bind(\u0026amp;mgr, \u0026#34;80\u0026#34;, ev_handler_function); mg_set_protocol_http_websocket(c); // create an event loop by calling mg_mgr_poll() in a loop for (;;) { mg_mgr_poll(\u0026amp;mgr, 1000); } Memory buffers 每个connection连接都有一个数据发送缓冲区（struct mg_connection::send_mbuf）与数据接收缓冲区（struct mg_connection::recv_mbuf）。当接收到数据时，mongoose将数据添加到recv_mbuf，并触发recv_mbuf 事件消息；当mongoose发送数据后，将已发送的数据从struct mg_connection::send_mbuf 中抛弃，并触发MG_EV_SEND 事件消息；当connection连接关闭时，将发送MG_EV_CLOSE 事件消息。 Event handler Event handler function的处理示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static void ev_handler(struct ns_connection *nc, int ev, void *p) { switch (ev) { case NS_ACCEPT: case NS_CONNECT: // Do something break; case NS_CLOSE: // close event break; case NS_RECV: // data received break; default: break; } } 主要参数说明如下：\nstruct mg_connection *nc 收到数据对应的connection\nint ev Event number，请参考《mongoose支持的Event列表》\nvoid *p 接收到的数据的指针，不同消息该参数有不同的含义\nmongoose支持的Event列表：\nMG_EV_ACCEPT: sent when a new server connection is accepted by a listening connection. void *ev_data is union socket_address of the remote peer.\nMG_EV_CONNECT: sent when a new outbound connection created by mg_connect() either failed or succeeded. void *ev_data is int *success. If success is 0, then the connection has been established, otherwise it contains an error code. See mg_connect_opt() function for code example.\nMG_EV_RECV: New data is received and appended to the end of recv_mbuf. void *ev_data is int *num_received_bytes. Typically, event handler should check received data in nc-\u0026gt;recv_mbuf, discard processed data by calling mbuf_remove(), set connection flags nc-\u0026gt;flags if necessary (see structmg_connection) and write data the remote peer by output functions like mg_send().WARNING: Mongoose uses realloc() to expand the receive buffer. It is the user\u0026rsquo;s responsibility to discard processed data from the beginning of the receive buffer, note the mbuf_remove() call in the example above.\nMG_EV_SEND: Mongoose has written data to the remote peer and discarded written data from the mg_connection::send_mbuf. void *ev_data is int*num_sent_bytes.NOTE: Mongoose output functions only append data to the mg_connection::send_mbuf. They do not do any socket writes. An actual IO is done by mg_mgr_poll(). An MG_EV_SEND event is just a notification about an IO has been done.\nMG_EV_POLL: Sent to all connections on each invocation of mg_mgr_poll(). This event could be used to do any housekeeping, for example check whether a certain timeout has expired and closes the connection or send heartbeat message, etc.\nMG_EV_TIMER: Sent to the connection if mg_set_timer() was called.\nConnection address format mongoose 创建conecction连接地址格式如下：\n1 [PROTO://][HOST:]PORT PROTO 协议名称，如 TCP 、 UDP 等，默认是 TCP\nHOST 连接的IPv4/IPv6地址名HOST名称\nPORT 连接的端口号\nconnection连接地址格式示例：\n1 2 udp://8080 tcp://127.0.0.1:8080 Using SSL on TCP SSL_CERT PEM format certificate. For listening connections, certificate file must contain private key and server certificate concatenated together; For client connections, it should be a client certificate file.\nCA_CERT PEM format certificate. A certificate authority (CA) PEM file, and it is optional (can be set to NULL). If ca_cert is non-NULL, then the connection is so-called two-way-SSL: other peer\u0026rsquo;s certificate is checked against the ca_cert.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int main(void) { struct mg_mgr mgr; struct mg_connection *c; struct mg_bind_opts bind_opts; mg_mgr_init(\u0026amp;mgr, NULL); memset(\u0026amp;bind_opts, 0, sizeof(bind_opts)); bind_opts.ssl_cert = \u0026#34;cert.pem\u0026#34;; bind_opts.ssl_key = \u0026#34;key.pem\u0026#34;; // Use bind_opts to specify SSL certificate \u0026amp; key file c = mg_bind_opt(\u0026amp;mgr, \u0026#34;443\u0026#34;, ev_handler, bind_opts); mg_set_protocol_http_websocket(c); ... } SSL证书生成方式：\n1 2 # @see: https://www.openssl.org/docs/manmaster/man1/openssl-req.html openssl req -nodes -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 9999 参考引用 https://github.com/cesanta/mongoose\nhttps://cesanta.com/docs/overview/intro.html\nhttps://www.openssl.org/docs/manmaster/man1/openssl-req.html\n","permalink":"https://blog.yygz.org/zh/program/network/mongoose/","summary":"mongoose介绍 mongoose 是一个标准的 C 语言网络通信模块，是嵌入式网络编程的瑞士军刀。mongoose 提供非阻塞的事件驱动的 TCP, UDP, HTTP, WebSocket, CoAP, MQTT 的服务端","title":"mongoose介绍"},{"content":"cookie/session cookie cookie是一种客户端会话跟踪技术，用于将网页的数据存储到浏览器中。当关闭浏览器或到过期时间时，cookie将失效。\ncookie存在大小限制，一般个数限制为20~50，大小限制在4KB左右。\ncookie在每次请求时将携带在HTTP头中，如果cookie保存过多数据可能存在性能问题。\nCaution:\n浏览器可能禁用cookie 不要利用cookie保存隐私数据 设置HttpOnly属性可避免XSS攻击 session session为会话数据，保存在Web服务器上，主要负责访问者与网站之间的交互。\nHTML5新增存储方案 HTML5中新增存储方案，包括sessionStorage、localStorage、WebSQL、IndexedDB。下列所有存储方案均遵循同源策略限制。\nlocalStorage localStorage生命周期是永久，可实现数据持久化存储。除非用户手动清除，否则localStorage存储的数据一直保存在浏览器中。\nlocalStorage的大小一般为5MB，不参与与服务端的通信。\nCaution: localStorage在浏览器隐私模式下不可读取；存储内容多会消耗内存空间，导致页面卡顿。\nsessionStorage sessionStorage仅在当前会话下有效，关闭页面或者浏览器后被清理并失效。\nsessionStorage的大小一般为5MB。\nCaution: sessionStorage无法跨Tab共享： 打开新页面时，将导致session失效；通过Duplicate 复制Tab时，sessionStorage失效。故在持久化存储时，优先考虑localStorage。\nWebSQL WebSQL数据库API不是HTML5规范的一部分，但它是一个独立的规范，引入一组使用SQL操作客户端数据库的API。\nWebSQL与关系数据库的概念相似，支持openDatabase/transaction/executeSQL 等操作，在Chrome浏览器中支持，一般情况下较少使用，作为临时存储或缓存使用。\nCaution: 仅Chrome、Safari、Opera支持，IE、Firefox等浏览器不支持。\nIndexedDB IndexedDB是浏览器提供的本地数据库存储，允许存储大容量数据，提供查找接口、建立索引等功能；但IndexedDB不支持SQL，接近NoSQL数据库。\nIndexedDB具有键值存储、异步、支持事务、同源限制（不支持跨域访问）、大容量（\u0026gt;=250MB）、支持二进制等特性。\n前端框架存储方案介绍 React Redux-persist\nRedux-persist 通过将redux存储的数据缓存到localStorage中实现数据持久化存储。\nreact-redux\nReact-redux将数据存储在内存中，当页面刷新时，存储的数据将被重置。\n其它存储方案 Cache Storage Cache Storage存储Response对象，即存储HTTP响应。Cache Storage是多个Cache的集合，每个Cache可以存储多个Response对象。\nCache Storage在浏览器上的引用名是caches而不是驼峰写法的cacheStorage ，它定义在ServiceWorker规范中。\nApplication Cache HTML5引入了应用程序缓存技术，意味着web应用可以进行缓存。在没有网络的情况下，通过创建cache manifest文件，可以轻松创建离线应用。目前主流浏览器均支持Application cache。\nApplication cache有三个优势：离线浏览、提升页面的载入速度、降低服务器压力。\nApplication cache主要存储静态资源。使用时服务端需要维护一个manifest清单，浏览器需要进行简单设置。\n应用场景分析 存储用户登陆状态 在大多数Web应用中，当用户登陆后，后端生成无意义的字符串token ，同时将token返回给前端。前端在后续所有请求中，将token附加到Header中传输到后端，后端进行token校验。前端在存储Token时，主流的如下几种方案：\nsessionStorage: 会话期间内存储，但无法跨浏览器Tab共享数据。\nlocalStrogage: 永久存储。当token过期时，需要重新设置，涉及同步处理；当网站被XSS注入攻击后，对方可能截取localStorage中的数据；localStorage是同步操作，频繁读取可能存在性能问题。\ncookie: 使用cookie存储用户登陆状态是目前Web开发主流中的主流。\n","permalink":"https://blog.yygz.org/zh/program/frontend/frontend_storage/","summary":"cookie/session cookie cookie是一种客户端会话跟踪技术，用于将网页的数据存储到浏览器中。当关闭浏览器或到过期时间时，cookie将失效。 cookie存在大","title":"前端存储方案"},{"content":"《读书与做人》简介 一代学术宗师季羡林先生，道德高尚，学问渊深，文章亦足以动人。\n季老谈读书，深入浅出，举重若轻，以大学者而写作小文章，从中可见出一代学问家对学术的真诚与崇敬，读者亦可从中体悟到文史学科的一般入门途径。\n季老论人生，信笔拈来，娓娓道出，以近于期颐之历练与心态，平和面对人世间的种种苦难，深于情，而不矫揉造作；明于理，而以平实朴素笔调发之，可给人以启迪与心灵的抚慰。\n读书笔记 上个月初购买kindle之后，一段时间内致力于kindle电子书的收集，《读书与做人》是第一本找到的令人满意的电子书。在新阅读设备及新书的双重愉悦下，利用一个星期的业余时间阅读完该书，颇有收获，闲暇时记录下来以备将来复习。\n从书名来看，包括读书与做人两部分，但从内容角度，可以分为自传、序集、做人三部分。\n第一部分自传，从出生、小学、中学、大学、德国留学、归国后北大任教、翻译及文学推广，简短的文字描述了季老平淡、充实、传奇的一生。通过作者的自述，发现大部份熟知的成功人士所具备的经历在季老身上都完美呈现。在小时候不仅有极高的语言天赋，还博学多识，有读无类，不管英语或国学，都为接下来的发展打下坚实的基础。人并非生而知之，一个人的成功，离不开外缘与内因，在清华读书期间，跟随陈寅恪、朱光潜两位国学大师学习，潜移默化中影响深远，终身在这条道路上奋斗，是为外缘；德国哥廷根留学期间，潜心研学佛教史及梵文、巴利文、俄文、火星罗文等多门语言，正所谓十年寒窗无人知，一朝成名天下知，十年闭关研学是为内因，积淀与升华，成为一代国学大师与学界泰斗。这让我想到了另一位国学大师南怀谨，也有类似的经历，早年游学，涉猎多方，峨眉山三年关闭，为后续人生道路奠下基础。\n第二部分序集，是季老为其它出版作品写书的序言集合。生平很少写序言，写必有因，写必无假话，其书都可以作为我们的补充阅读。\n第三部分做人，流露出对青年一代做事做人的殷切关怀，以小见大，讨论人与自然、人与自身、人与社会的相处之道，也是对其自身的总结与自述。 经过这本书，认识到季老是如此一个可爱的人，有风趣、有风骨、有脾气，恰是一个身边人，恰是我们的一个外缘。\n","permalink":"https://blog.yygz.org/zh/reading/note/jixianlin_dushu_yu_zuoren/","summary":"《读书与做人》简介 一代学术宗师季羡林先生，道德高尚，学问渊深，文章亦足以动人。 季老谈读书，深入浅出，举重若轻，以大学者而写作小文章，从中可见","title":"读书笔记 - [季羡林]读书与做人"},{"content":"\nClang-format简介 clang-format是一个代码格式化的工具，支持C/C++/Java/JavaScript/Objective-C/Protobuf等多种语言，并提供LLVM、Google、Visual Studio（仅VSCode支持）、Chromium、Mozilla、WebKit等多种默认代码规范支持。\nUsage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 $ clang-format -help OVERVIEW: A tool to format C/C++/Java/JavaScript/Objective-C/Protobuf code. If no arguments are specified, it formats the code from standard input and writes the result to the standard output. If \u0026lt;file\u0026gt;s are given, it reformats the files. If -i is specified together with \u0026lt;file\u0026gt;s, the files are edited in-place. Otherwise, the result is written to the standard output. USAGE: clang-format [options] [\u0026lt;file\u0026gt; ...] OPTIONS: Clang-format options: -assume-filename=\u0026lt;string\u0026gt; - When reading from stdin, clang-format assumes this filename to look for a style config file (with -style=file) and to determine the language. -cursor=\u0026lt;uint\u0026gt; - The position of the cursor when invoking clang-format from an editor integration -dump-config - Dump configuration options to stdout and exit. Can be used with -style option. -fallback-style=\u0026lt;string\u0026gt; - The name of the predefined style used as a fallback in case clang-format is invoked with -style=file, but can not find the .clang-format file to use. Use -fallback-style=none to skip formatting. -i - Inplace edit \u0026lt;file\u0026gt;s, if specified. -length=\u0026lt;uint\u0026gt; - Format a range of this length (in bytes). Multiple ranges can be formatted by specifying several -offset and -length pairs. When only a single -offset is specified without -length, clang-format will format up to the end of the file. Can only be used with one input file. -lines=\u0026lt;string\u0026gt; - \u0026lt;start line\u0026gt;:\u0026lt;end line\u0026gt; - format a range of lines (both 1-based). Multiple ranges can be formatted by specifying several -lines arguments. Can\u0026#39;t be used with -offset and -length. Can only be used with one input file. -offset=\u0026lt;uint\u0026gt; - Format a range starting at this byte offset. Multiple ranges can be formatted by specifying several -offset and -length pairs. Can only be used with one input file. -output-replacements-xml - Output replacements as XML. -sort-includes - Sort touched include lines -style=\u0026lt;string\u0026gt; - Coding style, currently supports: LLVM, Google, Chromium, Mozilla, WebKit. Use -style=file to load style configuration from .clang-format file located in one of the parent directories of the source file (or current directory for stdin). Use -style=\u0026#34;{key: value, ...}\u0026#34; to set specific parameters, e.g.: -style=\u0026#34;{BasedOnStyle: llvm, IndentWidth: 8}\u0026#34; -verbose - If set, shows the list of processed files Generic Options: -help - Display available options (-help-hidden for more) -help-list - Display list of available options (-help-list-hidden for more) -version - Display the version of this program 创建.clang-format文件 1 clang-format -style=google -dump-config \u0026gt; .clang-format Clang-Format配置介绍 Clang-Format 可以通过 -style=\u0026quot;{key: value, \u0026hellip;}\u0026quot; 直接指定命令行参数的配置，也可以通过 -style=file 指定代码格式化配置文件；也可以从工作目录中读取.clang-format 或 _clang-format代码格式化配置文件。\n.clang-format是一个YAML格式的配置文件：\n1 2 3 4 key1: value1 key2: value2 # A comment. ... .clang-format文件可以同时配置多种语言的格式化配置参数，文件前面未指定的配置项为默认配置项，对所有语言都有效，但指定语言下相同的配置项将覆盖默认的配置项。clang-format工具可以自动识别代码文件的语言类型，也可以通过-assume-filename=指定语言。多语言的配置文件示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 --- # We\u0026#39;ll use defaults from the LLVM style, but with 4 columns indentation. BasedOnStyle: LLVM IndentWidth: 4 --- Language: Cpp # Force pointers to the type for C++. DerivePointerAlignment: false PointerAlignment: Left --- Language: JavaScript # Use 100 columns for JS. ColumnLimit: 100 --- Language: Proto # Don\u0026#39;t format .proto files. DisableFormat: true ... 当不期望clang-format格式化某一段代码时，可以采用下面的注释：\n1 2 3 4 5 int formatted_code; // clang-format off void unformatted_code ; // clang-format on void formatted_code_again; 注：\n// clang-format on or /* clang-format on */等效\n// clang-format off or /* clang-format off */等效\nClang-Format 可选配置列表 (常用) BasedOnStyle_ (string）_ 指定标准的基础代码规范式样，取值包括 LLVM、Google、Chromium、Mozilla、WebKit等\nAccessModifierOffset_ (int)_ 访问权限关键字的缩进，如public\nAlignAfterOpenBracket 括号中的参数是否需要对齐\n**AlignConsecutiveAssignments **(bool) 赋值操作时是否需要对齐，如当设置为true时，\nint aaaa = 12; int b = 23; int ccc = 23;\n1 2 3 4 5 6 7 8 9 - **AlignConsecutiveDeclarations **_(bool)_ \u0026gt; 变量声明时是否需要对齐，如当设置为true时 \u0026gt; ```cpp int aaaa = 12; float b = 23; std::string ccc = 23; AlignEscapedNewlines 使用backslashes()换行时()的设置方式，包括不对齐、左对齐、右对齐\n**AlignOperands **(bool) 表达式或者语句拆分为多行时的是否需要对齐\nint aaa = bbbbbbbbbbbbbbb + ccccccccccccccc;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 - **AlignTrailingComments **_(bool)_ \u0026gt; 注释是否需要对齐 - **AllowAllParametersOfDeclarationOnNextLine **_(bool)_ \u0026gt; 如何函数声明时包含多行，每个参数是否需要单独列一行 - **AllowShortBlocksOnASingleLine **_(bool)_ \u0026gt; 简单语句是否需要写在一行。 E.g., this allows `if (a) { return; }` to be put on a single line. - **AllowShortCaseLabelsOnASingleLine **_(bool)_ \u0026gt; case标签是否需要保持在一行 ```cpp // true: // false: switch (a) { vs. switch (a) { case 1: x = 1; break; case 1: case 2: return; x = 1; } break; case 2: return; } AllowShortFunctionsOnASingleLine 短函数是否可以保持在一行\n**AllowShortIfStatementsOnASingleLine **(bool) 简单 if 语句是否可以保持在一行\n**AllowShortLoopsOnASingleLine **(bool) 简单循环语句是否可以保持在一行\nAlwaysBreakAfterReturnType 数据返回值的可选格式\nAlwaysBreakTemplateDeclarations 模板声明时的换行式样\n**BinPackArguments **(bool) 函数调用时参数放在一行还是每个参数一行\n**BinPackParameters **(bool) 函数声明或定义时参数放在一行还是每个参数一行\nBraceWrapping / BreakBeforeBraces 大括号的使用方式\n**BreakBeforeTernaryOperators **(bool) 三元操作符时是否需要换行\n1 2 3 4 5 6 7 8 9 true: veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ? firstValue : SecondValueVeryVeryVeryVeryLong; false: veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongDescription ? firstValue : SecondValueVeryVeryVeryVeryLong; BreakConstructorInitializers 构造函数成员初始化列表的的式样配置\nBreakInheritanceList 类多重继承时父类的式样配置\n**BreakStringLiterals **(bool) 是否允许对字符串进行格式化\n**ColumnLimit **(unsigned) The column limit.\nA column limit of 0 means that there is no column limit. In this case, clang-format will respect the input’s line breaking decisions within statements unless they contradict other rules.\n**CompactNamespaces **(bool) 是否允许namespace打包到一行，或者每个namespace分行\n1 2 3 4 5 6 7 8 9 true: namespace Foo { namespace Bar { }} false: namespace Foo { namespace Bar { } } ConstructorInitializerAllOnOneLineOrOnePerLine If the constructor initializers don’t fit on a line, put each initializer on its own line.\nConstructorInitializerIndentWidth (unsigned) 构造函数成员初始化列表的缩进数量\nContinuationIndentWidth (unsigned) 行缩进数量\nCpp11BracedListStyle (bool) If true, format braced lists as best suited for C++11 braced lists.\n1 2 3 4 5 true: false: vector\u0026lt;int\u0026gt; x{1, 2, 3, 4}; vs. vector\u0026lt;int\u0026gt; x{ 1, 2, 3, 4 }; vector\u0026lt;T\u0026gt; x{{}, {}, {}, {}}; vector\u0026lt;T\u0026gt; x{ {}, {}, {}, {} }; f(MyMap[{composite, key}]); f(MyMap[{ composite, key }]); new int[3]{1, 2, 3}; new int[3]{ 1, 2, 3 }; DerivePointerAlignment (bool) \u0026amp; and *的对齐方式\nDisableFormat (bool) 是否禁止代码格式化\nFixNamespaceComments (bool) 是否自动添加namespace的结束注释\n1 2 3 4 true: false: namespace a { vs. namespace a { foo(); foo(); } // namespace a; } IncludeBlocks (IncludeBlocksStyle) Dependent on the value, multiple #include blocks can be sorted as one and divided based on category.\nIndentCaseLabels (bool) case 语句是否需要缩进\n1 2 3 4 5 6 7 8 false: true: switch (fool) { vs. switch (fool) { case 1: case 1: bar(); bar(); break; break; default: default: plop(); plop(); } } IndentPPDirectives (PPDirectiveIndentStyle) 预处理指令或宏的缩进方式\nIndentWidth (unsigned) 行缩进的字符数量\nKeepEmptyLinesAtTheStartOfBlocks (bool) 是否需要在代码段前保持空行\n1 2 3 4 5 true: false: if (foo) { vs. if (foo) { bar(); bar(); } } Language (LanguageKind) 指定语言类型\nLK_None (in configuration: None) Do not use.\nLK_Cpp (in configuration: Cpp) Should be used for C, C++.\nLK_Java (in configuration: Java) Should be used for Java.\nLK_JavaScript (in configuration: JavaScript) Should be used for JavaScript.\nLK_ObjC (in configuration: ObjC) Should be used for Objective-C, Objective-C++.\nLK_Proto (in configuration: Proto) Should be used for Protocol Buffers (https://developers.google.com/protocol-buffers/).\nLK_TableGen (in configuration: TableGen) Should be used for TableGen code.\nLK_TextProto (in configuration: TextProto) Should be used for Protocol Buffer messages in text format (https://developers.google.com/protocol-buffers/).\nMaxEmptyLinesToKeep (unsigned)\nThe maximum number of consecutive empty lines to keep.\n1 2 3 4 5 6 7 8 MaxEmptyLinesToKeep: 1 vs. MaxEmptyLinesToKeep: 0 int f() { int f() { int = 1; int i = 1; i = foo(); i = foo(); return i; } return i; } NamespaceIndentation (NamespaceIndentationKind) namespace 的缩进方式\nPointerAlignment (PointerAlignmentStyle) 指针与引用的对齐方式\nReflowComments (bool) If true, clang-format will attempt to re-flow comments.\n1 2 3 4 5 6 7 8 9 false: // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of information */ true: // veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of // information /* second veryVeryVeryVeryVeryVeryVeryVeryVeryVeryVeryLongComment with plenty of * information */ SortIncludes (bool) 是否对 #include 的头文件进行排序\nSortUsingDeclarations (bool) 是否对声明进行排序\n1 2 3 false: true: using std::cout; vs. using std::cin; using std::cin; using std::cout; SpaceAfterCStyleCast (bool) 是否对 C 语言风格的类型转换添加空格\n1 2 true: false: (int) i; vs. (int)i; SpaceAfterTemplateKeyword (bool) template 关键字后是否需要添加空格\n1 2 true: false: template \u0026lt;int\u0026gt; void foo(); vs. template\u0026lt;int\u0026gt; void foo(); SpaceBeforeAssignmentOperators (bool) 赋值操作符前是否需要添加空格\n1 2 3 true: false: int a = 5; vs. int a=5; a += 42 a+=42; SpaceBeforeCpp11BracedList (bool) C11风格的对象初始化时是否需要添加空格\n1 2 3 4 5 true: false: Foo foo { bar }; vs. Foo foo{ bar }; Foo {}; Foo{}; vector\u0026lt;int\u0026gt; { 1, 2, 3 }; vector\u0026lt;int\u0026gt;{ 1, 2, 3 }; new int[3] { 1, 2, 3 }; new int[3]{ 1, 2, 3 }; SpaceBeforeCtorInitializerColon (bool) 构造函数成员初始化列表的冒号(:)前是否需要添加空格\n1 2 true: false: Foo::Foo() : a(a) {} Foo::Foo(): a(a) {} SpaceBeforeInheritanceColon (bool) 类继承时是否需要在冒号(:)前添加括号\n1 2 true: false: class Foo : Bar {} vs. class Foo: Bar {} SpaceBeforeParens (SpaceBeforeParensOptions) 括号前后的空格处理\nSpaceBeforeRangeBasedForLoopColon (bool) If false, spaces will be removed before range-based for loop colon.\n1 2 true: false: for (auto v : values) {} vs. for(auto v: values) {} SpaceInEmptyParentheses (bool) 空括号（）中是否需要添加空格\n1 2 3 4 5 6 7 true: false: void f( ) { vs. void f() { int x[] = {foo( ), bar( )}; int x[] = {foo(), bar()}; if (true) { if (true) { f( ); f(); } } } } SpacesBeforeTrailingComments (unsigned) 注释代码前需要添加的空格数量\n1 2 3 4 5 6 SpacesBeforeTrailingComments: 3 void f() { if (true) { // foo1 f(); // bar } // foo } SpacesInAngles (bool) \u0026lt;\u0026gt; 中是否要使用空格\n1 2 3 true: false: static_cast\u0026lt; int \u0026gt;(arg); vs. static_cast\u0026lt;int\u0026gt;(arg); std::function\u0026lt; void(int) \u0026gt; fct; std::function\u0026lt;void(int)\u0026gt; fct; SpacesInCStyleCastParentheses (bool) C语言风格的类型转换时是否需要在括号中添加空格\n1 2 true: false: x = ( int32 )y vs. x = (int32)y SpacesInContainerLiterals (bool) 容器列表中的空格\n1 2 3 true: false: var arr = [ 1, 2, 3 ]; vs. var arr = [1, 2, 3]; f({a : 1, b : 2, c : 3}); f({a: 1, b: 2, c: 3}); SpacesInParentheses (bool) () 中的空格处理\n1 2 true: false: t f( Deleted \u0026amp; ) \u0026amp; = delete; vs. t f(Deleted \u0026amp;) \u0026amp; = delete; SpacesInSquareBrackets (bool) [与]中的空格处理\n1 2 3 true: false: int a[ 5 ]; vs. int a[5]; std::unique_ptr\u0026lt;int[]\u0026gt; foo() {} // Won\u0026#39;t be affected Standard (LanguageStandard) C++标准的类型，Format compatible with this standard, e.g. use A\u0026lt;A\u0026lt;int\u0026gt; \u0026gt; instead of A\u0026lt;A\u0026lt;int\u0026gt;\u0026gt; for LS_Cpp03.\nLS_Cpp03 (in configuration: Cpp03) Use C++03-compatible syntax.\nLS_Cpp11 (in configuration: Cpp11) Use features of C++11, C++14 and C++1z (e.g. A\u0026lt;A\u0026lt;int\u0026gt;\u0026gt; instead of A\u0026lt;A\u0026lt;int\u0026gt; \u0026gt;).\nLS_Auto (in configuration: Auto) Automatic detection based on the input.\nTabWidth (unsigned)\n设置tab stops的缩进量\nUseTab (UseTabStyle) 是否使用tab\n.clang-format 配置文件示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 # Style options please see https://clang.llvm.org/docs/ClangFormatStyleOptions.html # The number of columns to use for indentation IndentWidth: 4 --- Language: Cpp BasedOnStyle: Google # The extra indent or outdent of access modifiers, e.g. public AccessModifierOffset: -1 # 括号中的参数是否需要对齐 AlignAfterOpenBracket: Align # 连续的赋值语句是否需要在\u0026#39;=\u0026#39;处对齐 AlignConsecutiveAssignments: true # 连续声明的变更是否需要对齐 AlignConsecutiveDeclarations: false # Options for aligning backslashes in escaped newlines AlignEscapedNewlines: Left # 操作数及三元操作符对齐 AlignOperands: true # 注释对齐 AlignTrailingComments: true # 函数声明过长时是否每个参数作为一行处理 AllowAllParametersOfDeclarationOnNextLine: false # Allows contracting simple braced statements to a single line AllowShortBlocksOnASingleLine: false # case关键字是否与语句放在一行 AllowShortCaseLabelsOnASingleLine: false # 单语句或短函数是否可以放在一行 AllowShortFunctionsOnASingleLine: Inline # IF 单语句代码是否可以放在一行 AllowShortIfStatementsOnASingleLine: true # 单语句循环体是否可以与循环放在一行 AllowShortLoopsOnASingleLine: true # AlwaysBreakAfterDefinitionReturnType 选项将被弃用 AlwaysBreakAfterDefinitionReturnType: None # The function declaration return type breaking style to use AlwaysBreakAfterReturnType: None # 多行字符串是否需要另起一行 AlwaysBreakBeforeMultilineStrings: true # 模板声明时是否需要另起一行 AlwaysBreakTemplateDeclarations: Yes # 函数调用时参数打包对齐 BinPackArguments: true # 函数声明或定义时是否需要参数打包对齐 BinPackParameters: false # 大括号的处理行为 BraceWrapping: AfterClass: false AfterControlStatement: false AfterEnum: false AfterFunction: false AfterNamespace: false AfterObjCDeclaration: false AfterStruct: false AfterUnion: false AfterExternBlock: false BeforeCatch: false BeforeElse: false IndentBraces: false SplitEmptyFunction: true SplitEmptyRecord: true SplitEmptyNamespace: true # The way to wrap binary operators BreakBeforeBinaryOperators: None # The brace breaking style to use BreakBeforeBraces: Attach BreakBeforeInheritanceComma: false # The inheritance list style to use BreakInheritanceList: AfterColon # 三元操作号对齐 BreakBeforeTernaryOperators: true BreakConstructorInitializersBeforeComma: false BreakConstructorInitializers: BeforeColon BreakAfterJavaFieldAnnotations: false # Allow breaking string literals when formatting BreakStringLiterals: true # 允许每行字符最大长度 ColumnLimit: 120 CommentPragmas: \u0026#39;^ IWYU pragma:\u0026#39; # 是否允许多个namespace声明在同一行 CompactNamespaces: false # If the constructor initializers don’t fit on a line, put each initializer on its own line ConstructorInitializerAllOnOneLineOrOnePerLine: true # The number of characters to use for indentation of constructor initializer lists as well as inheritance lists ConstructorInitializerIndentWidth: 4 # Indent width for line continuations ContinuationIndentWidth: 4 Cpp11BracedListStyle: true DerivePointerAlignment: true # 禁止代码格式化 DisableFormat: false ExperimentalAutoDetectBinPacking: false # 是否自动添加namespace结束的注释 FixNamespaceComments: true ForEachMacros: - foreach - Q_FOREACH - BOOST_FOREACH # Dependent on the value, multiple #include blocks can be sorted as one and divided based on category IncludeBlocks: Preserve # Regular expressions denoting the different #include categories used for ordering #includes IncludeCategories: - Regex: \u0026#39;^\u0026lt;ext/.*\\.h\u0026gt;\u0026#39; Priority: 2 - Regex: \u0026#39;^\u0026lt;.*\\.h\u0026gt;\u0026#39; Priority: 1 - Regex: \u0026#39;^\u0026lt;.*\u0026#39; Priority: 2 - Regex: \u0026#39;.*\u0026#39; Priority: 3 IncludeIsMainRegex: \u0026#39;([-_](test|unittest))?$\u0026#39; # case关键字是否需要缩进 IndentCaseLabels: true # 预处理指定或宏是否需要缩进 IndentPPDirectives: None # 当函数声明的返回值与函数名不在一行时，函数名是否需要缩进 IndentWrappedFunctionNames: false JavaScriptQuotes: Leave JavaScriptWrapImports: true # 是否在代码段前添加空格 KeepEmptyLinesAtTheStartOfBlocks: false MacroBlockBegin: \u0026#39;\u0026#39; MacroBlockEnd: \u0026#39;\u0026#39; # 允许最大的空行数量 MaxEmptyLinesToKeep: 1 # namespace中的子namespace与代码是否需要缩进 NamespaceIndentation: None ObjCBinPackProtocolList: Never ObjCBlockIndentWidth: 2 ObjCSpaceAfterProperty: false ObjCSpaceBeforeProtocolList: true PenaltyBreakAssignment: 2 PenaltyBreakBeforeFirstCallParameter: 1 PenaltyBreakComment: 300 PenaltyBreakFirstLessLess: 120 PenaltyBreakString: 1000 PenaltyBreakTemplateDeclaration: 10 PenaltyExcessCharacter: 1000000 # 函数允许的最大长度(行) PenaltyReturnTypeOnItsOwnLine: 200 # 指针与引用的对齐方式 PointerAlignment: Left # Defines hints for detecting supported languages code blocks in raw strings RawStringFormats: - Language: Cpp Delimiters: - cc - CC - cpp - Cpp - CPP - \u0026#39;c++\u0026#39; - \u0026#39;C++\u0026#39; CanonicalDelimiter: \u0026#39;\u0026#39; BasedOnStyle: google - Language: TextProto Delimiters: - pb - PB - proto - PROTO EnclosingFunctions: - EqualsProto - EquivToProto - PARSE_PARTIAL_TEXT_PROTO - PARSE_TEST_PROTO - PARSE_TEXT_PROTO - ParseTextOrDie - ParseTextProtoOrDie CanonicalDelimiter: \u0026#39;\u0026#39; BasedOnStyle: google # 是否对注释重新排列 ReflowComments: true # 是否对 #include 的头文件进行排序 SortIncludes: true # 是否对using的namespace排序 SortUsingDeclarations: true # C语言风格的类型转换的变量前是否添加空格 SpaceAfterCStyleCast: false # 模板关键字后是否需要添加空格 SpaceAfterTemplateKeyword: true # 赋值操作符前否是否需要添加空格 SpaceBeforeAssignmentOperators: true # C11风格的对象初始化是否需要添加空格 SpaceBeforeCpp11BracedList: true # 成员初始化列表的冒号前是否需要添加空格 SpaceBeforeCtorInitializerColon: true # 类继承时冒号前是否添加空格 SpaceBeforeInheritanceColon: true # 圆括号前后是否要添加空格 SpaceBeforeParens: ControlStatements # range-based的循环中的冒号(:)前是否添加空格 SpaceBeforeRangeBasedForLoopColon: true # 空括号()中是否需要添加空格 SpaceInEmptyParentheses: false # 行注释前需要添加的空格数量 SpacesBeforeTrailingComments: 2 # \u0026lt;\u0026gt;中是否需要添加空格 SpacesInAngles: false # 容器列表中是否需要添加空格 SpacesInContainerLiterals: true # C语言风格的类型转换时()中是否需要添加空格 SpacesInCStyleCastParentheses: false # ()中是否需要添加空格 SpacesInParentheses: false # []中是否需要添加空格 SpacesInSquareBrackets: false # 自动识别C++标准版本 Standard: Auto UseTab: Never ... 编辑器支持Clang-format介绍 VSCode Coding Formating插件 VSCode的C/C++插件使用Clang-Format支持源代码格式化。\n编辑器设置 1 2 editor.formatOnSave - 保存文档时自动对代码格式化 editor.formatOnType - 当用户输入分号（;）时对代码进行格式化 注： 当对代码进行格式化时，VSCode优先检查当前工作空间是否存在.clang-format文件，如果存在则采用此文件进行格式化，否则采用默认的C_Cpp.clang_format_fallbackStyle进行格式化。同时可以通过C_Cpp.clang_format_path指定本机指定版本的clang-format工具代码默认的版本。\nVIM集成 请参考 https://clang.llvm.org/docs/ClangFormat.html#vim-integration Emacs集成 请参考 https://clang.llvm.org/docs/ClangFormat.html#emacs-integration 扩展阅读 VSCode Code formatting介绍\nClang-Format 使用说明\nClang-Format Style Options\n","permalink":"https://blog.yygz.org/zh/program/format/clang_format/","summary":"Clang-format简介 clang-format是一个代码格式化的工具，支持C/C++/Java/JavaScript/Objectiv","title":"Clang format for C/C++/Java/JavaScript/Object-C"},{"content":"开发必备工具 VSCode Website: https://code.visualstudio.com/ 简介：This is the only editor which I used for my develop career since vscode released. Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of extensions for other languages and runtimes (such as C++, C#, Java, Python, PHP, Go, .NET).\nWarp Website: https://www.warp.dev/ 简介: The terminal for the 21st century. Modern features for modern development. Warp is a blazingly fast, Rust-based terminal that makes you and your team more productive at running, debugging, and deploying code.\n终端与命令行 ripgrep ( rg ) Website: https://github.com/BurntSushi/ripgrep 简介： ripgrep is a line-oriented search tool that recursively searches the current directory for a regex pattern. ripgrep is a line-oriented search tool that recursively searches the current directory for a regex pattern. By default, ripgrep will respect gitignore rules and automatically skip hidden files/directories and binary files. (To disable all automatic filtering by default, use rg -uuu.) ripgrep has first class support on Windows, macOS and Linux, with binary downloads available for every release. ripgrep is similar to other popular search tools like The Silver Searcher, ack and grep.\nfx Website: https://github.com/antonmedv/fx 简介: 一款格式化JSON的命令行工具，支持多颜色主题。 json_pp 简介: 一款格式化JSON的命令行工具。 hexyl Website: [https://github.com/sharkdp/hexy](https://github.com/sharkdp/hexyl) l 简介: A command-line hex viewer。 fx Website: https://github.com/axiros/terminal_markdown_viewer 简介: Styled Terminal Markdown Viewer。 少数派 Snipaste Website: https://www.snipaste.com/ 简介: Snipaste is a simple but powerful snipping tool, and also allows you to pin the screenshot back onto the screen. You can also convert text or color info in the clipboard into a floating image window. Such windows can be zoomed, rotated, flipped, made translucent, and even made click-through! If you are a programmer, a designer or whoever works much time before the computer, you will be surprised how it can help you get your work done more efficiently!\n","permalink":"https://blog.yygz.org/zh/soft/personal-recommend-utils/","summary":"开发必备工具 VSCode Website: https://code.visualstudio.com/ 简介：This is the only editor which I used for my develop career since vscode released. Visual Studio Code is a lightweight but powerful source code editor which runs on your desktop and is available for Windows, macOS and Linux. It comes with built-in support for JavaScript, TypeScript and Node.js and has a rich ecosystem of","title":"个人常用工具集"},{"content":"hello world!\n","permalink":"https://blog.yygz.org/zh/posts/hello-world/","summary":"hello world!","title":"Hello-world"},{"content":"Introduction This is bold text, and this is emphasized text.\nVisit the Hugo website!\n","permalink":"https://blog.yygz.org/zh/posts/my-first-post/","summary":"Introduction This is bold text, and this is emphasized text.\nVisit the Hugo website!","title":"My First Post"}]